'use strict';define(["src/util/versioning","superagent","src/util/util","fetch"],function(a,b,c,d){"use strict";function f(a){let b;const c=Math.min(100,a.length);for(let d=0;d<c;d++)if(";"===a[d]){b=d+1;break}const d=a.slice(b,b+7);if(b&&"base64,"===d)return b+=7,a.slice(b);throw new Error("Could not parse dataurl")}async function g(a,c){let d=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};if(await a.list(),!Array.isArray(c))throw new TypeError("Argument should be an array");if(0===c.length)return a.list();for(let b=0;b<c.length;b++)delete a.lastDoc._attachments[c[b]];const e=await b.put(a.docUrl).withCredentials().set("Content-Type","application/json").set("Accept","application/json").send(a.lastDoc);return e&&e.body&&e.body.rev&&(a.lastDoc._rev=e.body.rev),d.noRefresh?h(a,a.lastDoc._attachments):a.refresh()}function h(a,b){const c=[];let d=0;for(const e in b)c.push(b[e]),c[d].name=e,c[d].filename=e,c[d].url=encodeURI(`${a.docUrl}/${e}`),d++;return a.lastAttachmentsResult=c,c}function j(a){return a.name||a.filename}const k=/^data:([a-z]+\/[a-z]+)?;base64,/;return class{constructor(b){if(0===arguments.length){const b=a.lastLoaded.view.url;if(!b)throw new Error("couchdb attachments initialization failed: No view url");this.docUrl=b.replace(/\/[^/]+$/,"")}else this.docUrl=b}setDoc(a){this.lastDoc=a}async list(a){const b=this.lastDoc&&this.lastDoc._attachments;if(!this.lastDoc&&a)throw new Error("Unreachable");return b||a?(b||(this.lastDoc._attachments={}),this.attachmentsAsArray(this,this.lastDoc._attachments)):(await this.refresh(),this.list(!0))}async inlineUploads(a){let b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(await this.list(),!a)return h(this,this.lastAttachmentsResult);else{if(!Array.isArray(a))throw new TypeError("options must be an array");const c=[];for(let b=0;b<a.length;b++){let d=j(a[b]),g=a[b],h=g.data||g.file||g.content;if("string"==typeof h){if("base64"===g.encoding)this.lastDoc._attachments[d]={content_type:g.contentType,data:h};else{let a=k.exec(h.slice(0,64));this.lastDoc._attachments[d]=a?{content_type:g.contentType||a[1],data:h.slice(a[0].length)}:{content_type:g.contentType,data:btoa(unescape(encodeURIComponent(h)))}}}else if(h instanceof Blob||h instanceof ArrayBuffer){h instanceof ArrayBuffer&&(h=new Blob([h])),!g.contentType&&h.type&&(g.contentType=h.type);let a=new Promise((a,b)=>{let c=new FileReader;c.onload=function(b){return a({item:g,base64data:f(b.target.result)})},c.onerror=function(){return b(new Error("Error while reading file"))},c.readAsDataURL(h)});c.push(a)}else throw new Error("Item must have a valid data or file property")}const e=await Promise.all(c);for(let a=0;a<e.length;a++){const b=e[a];this.lastDoc._attachments[j(b.item)]={content_type:b.item.contentType,data:b.base64data}}return await d(this.docUrl,{method:"PUT",credentials:"include",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify(this.lastDoc)}),b.noRefresh?h(this,this.lastDoc._attachments):this.refresh()}}async upload(a){let d=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!a)throw new Error("Invalid arguments");let e=a.data||a.file||a.content;await this.list();let f=a.contentType;if(!f&&e instanceof Blob)f=e.type;else if("string"==typeof e){if("base64"===a.encoding)e=a.data;else{let b=k.exec(e.slice(0,64));b?(e=c.b64toBlob(e.slice(b[0].length),b[1]),f=b[1]):e=new Blob([e],{content_type:a.contentType})}}else if(!(e instanceof Blob))throw new Error("Data must be Blob or base64 dataUrl");if(!f)throw new Error("Content-Type unresolved. Cannot upload document without content-type");const g=await b.put(`${this.docUrl}/${j(a)}`).withCredentials().query({rev:this.lastDoc._rev}).set("Content-Type",f).set("Accept","application/json").send(e);return g&&g.body&&g.body.rev&&(this.lastDoc._rev=g.body.rev),d.noRefresh?h(this,this.lastDoc._attachments):this.refresh()}async get(a,c){c=c||{},await this.list();const e=this.lastDoc._attachments[a];if(!e)throw new Error(`The attachment ${a} does not exist`);const f=`${this.docUrl}/${a}`;if(!c.responseType){const d=b.get(f).withCredentials();e&&d.set("Accept",this.lastDoc._attachments[a].content_type);const g=await d.query({rev:this.lastDoc._rev});if(c.raw)return g.text;return c.responseType?g.xhr.response:g.body||g.text}else{const a=await d(f,{credentials:"include"});switch(c.responseType){case"arraybuffer":return a.arrayBuffer();case"blob":return a.blob();case"json":return a.json();case"text":return a.text();}}}async remove(a){let c=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(Array.isArray(a))return g(this,a,c);if(await this.list(),!this.lastDoc._attachments[a])throw new Error("Cannot remove attachment, attachment does not exist.");const d=await b.del(`${this.docUrl}/${a}`).withCredentials().query({rev:this.lastDoc._rev}).set("Accept","application/json");if(d&&d.body&&d.body.rev)return this.lastDoc._rev=d.body.rev,delete this.lastDoc._attachments[a],h(this,this.lastDoc._attachments);throw new Error("Unexpected error when removing attachments")}async refresh(){let a=await(await d(this.docUrl,{credentials:"include",headers:{Accept:"application/json"}})).json();return this.lastDoc=a,h(this,a._attachments)}fetchList(){return this.refresh()}attachmentsAsArray(){const a=[];let b=0;for(const c in this.lastDoc._attachments)a.push(this.lastDoc._attachments[c]),a[b].name=c,a[b].url=encodeURI(`${this.docUrl}/${c}`),b++;return this.lastAttachmentsResult=a,a}async uploads1(a){let c=1<arguments.length&&arguments[1]!==void 0?arguments[1]:{};if(!Array.isArray(a))throw new Error("uploads expects an array as parameter");const d=b.post(this.docUrl).withCredentials();for(let b=0;b<a.length;b++){const c=a[b];d.attach("_attachments",c,j(c))}d.field("_rev",this.lastDoc._rev);const e=await d;if(201!==e.status)throw new Error(`Error uploading attachments, couchdb returned status code ${e.status}`);return c.noRefresh?h(this,this.lastDoc._attachments):this.refresh()}}});
